# blog_api

## Оглавление
- [Описание](#description)
- [Запуск на сервере разработчика (localhost)](#local)
- [Примеры запросов](#requests)
- [Документация средствами Swagger](#documentation)

---
<a id=description></a>
## Описание
Данный проект решает задачу создания API для блога, который обеспечивает:

- Добавление статьи 
- Добавление комментария к статье
- Добавление комментария в ответ на другой комментарий (возможна любая вложенность)
- Получение всех комментариев к статье вплоть до 3 уровня вложенности
- Получение всех вложенных комментариев для комментария 3 уровня
- По ответу API комментариев можно воссоздать древовидную структуру
- Число запросов к базе данных не должно напрямую зависеть от количества комментариев, уровня вложенности. 

---
<a id=local></a>
## Запуск на сервере разработчика (localhost)
Проект настроен для работы с базой данных PostgreSQL. Если она не установлена, то установите её. Инструкцию по установке можно найти в [документации](https://postgrespro.ru/docs/postgresql/14/index).

Все нижеследующие инструкции выполняйте в консоли.
Первым делом необходимо клонировать проект с github.com. Перейдите в папку, в которую хотите клонировать проект. В консоли выполните:
```
git clone https://github.com/I-Iub/blog_api.git
```
Перейдите в папку клонированного проекта "blog_api/".
Создайте виртуальное окружение:
```
python3 -m venv venv
```
Активируйте виртуальное окружение:
```
source venv/bin/activate        # для Linux
source venv/Scripts/activate    # для Windows
```
Установите зависимости:
```
pip install -r requirements.txt
```
Перейдите в папку "blog/" и создайте в ней файл ".env". Откройте файл и пропишите там 
```
SECRET_KEY=<секретный_ключ_для_проекта_django>
DB_ENGINE=django.db.backends.postgresql
DB_NAME=<имя_базы_данных>
POSTGRES_USER=<имя_пользователя_базы_данных>
POSTGRES_PASSWORD=<пароль_базы_данных>
DB_HOST=127.0.0.1
DB_PORT=5432
```

Проверьте, что находитесь в папке "blog_api/blog/" и выполните миграции:
```
python manage.py migrate
```
Запустите сервер разработчика:
```
python manage.py runserver
```
Теперь проект доступен в браузере на локальном хосте 127.0.0.1:8000.

---
<a id=requests></a>
## Примеры запросов

#### Статьи

Для добавления статьи отправьте POST-запрос на эндпоинт 

`http://localhost:8000/api/v1/articles/`

В теле запроса передайте:
```
Content-Type: application/json

{
    "title": "Заголовок статьи",
    "text": "Текст статьи"
}
```
Ответ:
```
{
    "id": 1,
    "title": "Заголовок статьи",
    "text": "Текст статьи"
}
```

Для получение списка статей отправьте GET-запрос на эндпоинт 

`http://localhost:8000/api/v1/articles/`

Пример ответа (в базе данных три статьи):
```
[
  {
    "id": 3,
    "title": "Заголовок статьи",
    "text": "Текст статьи"
  },
  {
    "id": 2,
    "title": "Заголовок статьи",
    "text": "Текст статьи"
  },
  {
    "id": 1,
    "title": "Заголовок статьи",
    "text": "Текст статьи"
  }
]
```

Также разрешены GET-, PATCH-, PUT-, DELETE-запросы на эндпоинт 

`http://localhost:8000/api/v1/articles/<id_статьи>/`

Они работают стандартно.

#### Комментарии

Для добавления комментария к **статье** отправьте POST-запрос на эндпоинт

`http://127.0.0.1:8000/api/v1/articles/<id_статьи>/comments/`

В теле запроса передайте:
```
Content-Type: application/json

{
    "text": "Текст комментария."
}
```
К любому комментарию можно добавить другой, "вложенный" комментарий. Чтобы сделать вложенный комментарий, закрепив его за другой, родительский, нужно передать в параметре `parent` id родительского комментария:

`http://127.0.0.1:8000/api/v1/articles/<id_статьи>/comments/?parent=<id_родительского_комментария>`

На стороне базы данных в поле `"parent"` созданного в результате запроса комментария будет записан id родительского комментария. Кроме того автоматически каждому комментарию присваивается уровень вложенности, который записывается в поле `"level"`. Эти же поля (их значения) возвращаются при выполнении GET-запроса комментариев (пример запроса ниже). С помощью этих полей можно воссоздать дерево зависимостей комментариев. Легче всего это сделать, сгруппировав полученные комментарии сначала по уровню вложенности, а затем по id родительского комментария.

Для получения списка комментариев отправьте GET-запрос на эндпоинт

`http://127.0.0.1:8000/api/v1/articles/<id_статьи>/comments/`

Пример ответа:

```
[
  {
    "id": 1,
    "level": 1,
    "parent": null,
    "text": "Текст комментария."
  },
  {
    "id": 2,
    "level": 1,
    "parent": null,
    "text": "Текст комментария."
  },
  {
    "id": 3,
    "level": 2,
    "parent": 2,
    "text": "Текст комментария."
  }
]
```

В примере комментарий с id=3 закреплен за комментарием id=2. Можно считать, что комментарии, у которых `level=1`, и  `parent=null`, закреплены непосредственно за статьёй. 

Запросы GET, PATCH, PUT, DELETE на эндпоинт 

`http://localhost:8000/api/v1/articles/<id_статьи>/comments/<id_комментария>/` 

работают стандартно.

Но, кроме того, можно получить комментарии к статье только до определённой "глубины" вложенности. А также комментарии, которые являются вложенными для какого-либо комментария третьего уровня.

Чтобы получить комментарии, например, для третьего уровня вложенности, необходимо передать глубину в параметре запроса `"level"`: `level=3`. Пример: 

`http://127.0.0.1:8000/api/v1/articles/<id_статьи>/comments/?level=3`

В ответе вернуться комментарии с уровнем вложенности с первого по третий включительно.

Для получения всех вложенных комментариев для комментария третьего уровня создан отдельный эндпоинт:

`http://127.0.0.1:8000/api/v1/articles/<id_статьи>/comments/<id_комментария>/farther/`.

В параметрах запроса на месте `<id_комментария>` должен быть указан комментарий именно третьего уровня. Иначе не вернётся ни одного комментария. Кроме того, комментарий `<id_комментария>` должен быть "закреплен" за статьёй `<id_статьи>`, иначе не вернётся ни одного комментария.

---
<a id=documentation></a>
## Документация средствами Swagger

Документация доступна на 

`http://127.0.0.1:8000/swagger/`

`http://127.0.0.1:8000/redoc/`
